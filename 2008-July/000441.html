<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Al4nin-commits] r678 - trunk/purgatory
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/al4nin-commits/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:al4nin-commits%40lists.berlios.de?Subject=Re%3A%20%5BAl4nin-commits%5D%20r678%20-%20trunk/purgatory&In-Reply-To=%3C200807071310.m67DAilO009074%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000440.html">
   <LINK REL="Next"  HREF="000442.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Al4nin-commits] r678 - trunk/purgatory</H1>
    <B>heisenbug at mail.berlios.de</B> 
    <A HREF="mailto:al4nin-commits%40lists.berlios.de?Subject=Re%3A%20%5BAl4nin-commits%5D%20r678%20-%20trunk/purgatory&In-Reply-To=%3C200807071310.m67DAilO009074%40sheep.berlios.de%3E"
       TITLE="[Al4nin-commits] r678 - trunk/purgatory">heisenbug at mail.berlios.de
       </A><BR>
    <I>Mon Jul  7 15:10:44 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000440.html">[Al4nin-commits] r677 - trunk/purgatory/db
</A></li>
        <LI>Next message: <A HREF="000442.html">[Al4nin-commits] r679 - trunk/purgatory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#441">[ date ]</a>
              <a href="thread.html#441">[ thread ]</a>
              <a href="subject.html#441">[ subject ]</a>
              <a href="author.html#441">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: heisenbug
Date: 2008-07-07 15:10:42 +0200 (Mon, 07 Jul 2008)
New Revision: 678

Modified:
   trunk/purgatory/Thrist.lout
Log:
rewrite future work, add citations, other tweaks

Modified: trunk/purgatory/Thrist.lout
===================================================================
--- trunk/purgatory/Thrist.lout	2008-07-07 12:59:03 UTC (rev 677)
+++ trunk/purgatory/Thrist.lout	2008-07-07 13:10:42 UTC (rev 678)
@@ -1262,7 +1262,7 @@
 
 Since arrows in the Haskell world also originated from the generalization of function
 composition it is helpful to give a comparison of the @Haskell { Arrow } @I { type class } in Haskell and
-our Thrist datastructure. Obviously any instance of the Haskell type class @Haskell { Arrow } can
+our @Haskell { Thrist } data structure. Obviously any instance of the Haskell type class @Haskell { Arrow } can
 be expressed as a thrist. We have to accompany the @Haskell { Thrist Arrow } with an interpretation
 function that is rather canonic, and will be given in the Appendix @NumberOf { arrow.adapter }. This semantics obviously
 guarantees the arrow laws @Cite { $hughes00.arrows }. On the other hand thrists are not always
@@ -1358,14 +1358,15 @@
 @Begin
 @PP
 David Roundy's @I { Darcs } @Cite { $roundy.darcs2 } is a version control system
-which builds upon a @I {theory of patches} @Cite { $wikibooks.patch }, defining the evolution of data repositories (and
-documents therein) as a gradual application of individual changes. The recent adoption
-of GADTs into the system has lead to a two-parameter @Haskell {Patch} datatype and
+which builds upon a @I {theory of patches} @Cite { $wikibooks.patch }, defining
+the evolution of data repositories (and of documents therein) as a gradual application
+of individual changes. The recent adoption
+of GADTs into the system has led to a two-parameter @Haskell {Patch} datatype and
 @Haskell {FL}, @Haskell {RL} GADTs which are used for sequencing these (among others).
 The definition of @Haskell {FL} is identical to how our @Haskell {Thrist} would be
 defined in Haskell! Being hidden in a utility module, @Haskell {FL} entered the @I { Darcs }
 codebase in the year 2007 but its origins can be traced back to a brain-storming session at
-Haskell'05 workshop in Tallinn.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at I</A> {Haskell'05} workshop in Tallinn.
 @PP
 In his @I {Fun in the Afternoon} talk @Cite {$mcbride07.rstar}, Conor McBride proposed
 the free category {@I R}* as generalization to the conventional list datatype and several others.
@@ -1377,16 +1378,17 @@
 data List' :: * ~&gt; * ~&gt; * where
   Elem :: a -&gt; List' a a
 }
-is a similar adapter to the one in @NumberOf { section.arrow-monad } and @Haskell {Thrist List'} is the
+is a similar adapter to the one in Section @NumberOf { section.arrow-monad } and @Haskell {Thrist List'} is the
 datatype McBride proposes as the new list type. In this special case we really obtain
 a free category, since @Haskell {List'} defines identity morphisms.
 @PP
+Ever since the invention of Lisp the program-as-data idiom has been a treasure trove for functional programmers.
 Chuan-kai Lin's @I { Unimo } framework @Cite { $lin06.unimo } is an attempt to describe monads operationally
 by interpreting a datastructure that describes the monad. By the fact that the interpreter
 is proven to satisfy the monadic laws, a guarantee is given that the monadic semantics
-is fulfilled, regardless what callback functions the monad's creator supplies. GADTs appear in
-his work only as the datatypes modelling the @I { effect basis } of monads, while they are not needed
-for the general case.
+is fulfilled, regardless what callback functions the monad's creator supplies.
+GADTs appear in his work only as the datatypes modelling the @I { effect basis } of monads,
+while they are not needed for the general case.
 @PP
 Another example of the rekindled interest in modelling side-effecting computations in a purely functional
 manner is given by the Haskell Workshop paper of Swierstra et al. @Cite { $swierstra07.beast }, which demonstrates
@@ -1395,13 +1397,13 @@
 @PP
 Chris Heunen and Bart Jacobs' work @Cite { $heunenjacobs.monoid } on the connection of Arrows and Monads
 and their category theoretical formalisation is of relevance because it reveals the mathematical
-structure behind these constructs.
-Arrows appeared in the general mindset as a pragmatic approach to deal with a certain class of parsers
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at Cite</A> { $hughes00.arrows } that did not fit into the monadic framework.
-Nilsson provides a method for optimizing limited cases of arrow combinator libraries using GADTs. He
-is still bound to the limitations of the amesiac nature of function composition inside the arrow
-framework for functional reactive programming, but seem to gain some noticeable gains in performance
-especially in microbenchmarks that are modelling the arrow laws.
+structure behind these constructs, stating the common generalization to them as {@I monoids}.
+Arrows @Cite { $hughes00.arrows } appeared in the general mindset as a pragmatic approach to deal with
+a certain class of parsers that did not fit into the monadic framework @Cite { $duponcheel96.parser }.
+Nilsson @Cite { $nilsson05.frp } provides a method for optimizing limited cases of arrow combinator libraries using GADTs.
+In the scope of framework for functional reactive programming he is still bound to the limitations of the amesiac nature of
+function composition inside the arrow, but seem to gain some noticeable gains in performance especially with microbenchmarks
+modelling the arrow laws.
 @End @Section
 
 @Section
@@ -1413,59 +1415,53 @@
 GADT with two constructors strongly resembling classical lists, but with a
 side-condition that the types must be threaded. The semantics is provided by
 an interpretation function that can be provided separately for each first parameter
-of the Thrist type constructor.
+of the @Haskell {Thrist} type constructor.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at PP</A> We have further provided three examples for the usefulness of the thrist data
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A> We have provided three examples for the usefulness of the thrist data
 structure and demonstrated that the ability to take thrists apart and analyse is
 a very good arguments for their use. Also, all operations performed on thrists, such
 as subdivision, insertion and extension must be performed by algorithms that preserve
-the strong typing constraints that are imposed by the @Haskell { Thrist } data structure's
-typing rule. For this to work it is crucial that @Haskell { Thrist } is defined to be
+the strong typing constraints that are imposed by the @Haskell { Thrist } type constructor's
+typing rule. For this to work, it is crucial that @Haskell { Thrist } is defined to be
 a generalized algebraic datatype (GADT).
+
 @PP We have further shown that thrists generalize arrows naturally and monads with
-a shallow adaptation layer. Free categories can be modelled as thrists and we conjecture
-that computationally relevant categories can be fitted into the @Haskell { Thrist }
-framework.
+a shallow adaptation layer. We have identified free categories to be the closest
+relative of our thrists in the mathematical realm.
 @PP Last, but not least, we could successfully exploit {@Omega}'s extensible syntax
 to present thrists in a uniform and aestetical way, well alike {@I Haskell}'s syntax
 for lists, with the same ease of pattern matching and construction.
 @PP
 Although the above provides sufficient evidence of the usefulness of thrists, there
 is still plenty to find out.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at LP</A> what other useful @Haskell { p }s in @Haskell { Thrist p a b } exist?
-Since the @Haskell { a } and @Haskell { b } parameters can encode
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LP</A> What other useful @Haskell {p}s in @Haskell { Thrist p a b } exist?
+Since the @Haskell {a} and @Haskell {b} parameters can encode
 propositions, the @Haskell { Thrist } approach can convey the evolution
-of abstract properties, e.g. the adherence to the SSA form @Cite {appel}.
+of abstract properties, e.g. the adherence to the SSA form @Cite {$appel98.ssa}.
 Modern compiler architectures{ @FootNote { GCC @Cite {$gcc.ssa} and LLVM @Cite {$llvm.intro} being notable representants } }
 tend to favor this formalism for internal representation of imperative programs.
-Explicitly tracking def-use information paired with annotation preserving
-transformations might pave the way to certified compilers, but apperars to
+Explicitly tracking @I {def-use} information paired with annotation preserving
+transformations might pave the way to certified compilers, but appears to
 be a challenging task.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at LP</A> LLVM has a @I getelementpointer instruction, which allows to do offset calculations
-into deeply nested data structures. The descent from the encompassing pointer, array or
-structure type can be conveniently encoded as a thrist, where the underlying GADT
-provides constructors for dereferencing of pointers, picking of array elements
-and skipping over (resp. selecting) of structure members. This thrist can then
-easily converted into the sequence of integers that represents the intended
-datastructure part in the @I getelementpointer instruction.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at LP</A> is parametricity in the first parameter useful? I.e.
-can we formulate sensible functions on @Haskell { Thrist p a b }, where
-p is left universal?
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at LP</A> Given certain callback functions, can the @Haskell { Thrist } be accompanied with
-a generic interpretation function, in the style of @I {Unimo}? Would it be
-possible to instrument thrists with a monadic semantics this way?
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at LP</A> Folds on thrists. Hard because types vary. Existentials? Folds are very important
-for lists, so we need them.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at LP</A> Syntactical questions: can &quot;\&quot;do\&quot;&quot; (monadic) or &quot;\&quot;proc\&quot; ... \&quot;do\&quot;&quot; (arrow{
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at FootNote</A> { arrow syntax is available in certain Haskell implementatons, but not in @Omega}})
-syntax be used for more convenient construction of thrists than with the @Haskell { [a, b; r]l }
-notation?
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at LP</A> More generalization, though not very important for demonstration, generalizing the
-Thrist type signature to accept the last two parameters from any level of the @I { sort hierarchy }
-seems useful. Parity in generality at least with the built-in @Haskell { Equal } type seems
-desirable{ @FootNote { in @Omega its type signature is
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at Haskell</A> { Equal :: level b.forall (a::*(1 + b)).a ~&gt; a ~&gt; *0 } } }, but even
-different levels for the second and third parameters are conceivable.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LP</A> A similar question is that of restricted monads. Is it possible to provide a
+more generic adapter than the one presented in Section @NumberOf {section.arrow-monad},
+that encompasses restricted monads too?
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LP</A> LLVM @Cite {$llvm.intro} has a @I getelementpointer instruction, which allows to do offset calculations
+into deeply nested ({@CLang}-style) data structures. The descent from the encompassing pointer, array or
+structure type to the desired structure member can be conveniently encoded as a thrist,
+where the underlying GADT provides constructors for dereferencing of pointers, picking of array elements
+and skipping over (resp. selecting) of structure members. The resulting thrist can then
+easily converted into the sequence of integers that is encoded in the @I getelementpointer instruction.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LP</A> @I Parametricity is a powerful weapon in proving program properties. It seems a worthwile direction
+of research to find out which sensible algorithms on thrists exist on @Haskell { Thrist p a b }, where
+p is left universal. At first glance maps and folds seem to break because of the typing rule, but
+studying the correspondig free categories might show the way. As these transformations are essential
+for a wide range of regular data structures, we should be able to use similar higher-order functions too.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LP</A> While the syntax presented here is already quite palatable, it remains to be seen how thrists can be
+given syntactic sugar along the lines of the monadic ''do`` (or even arrow{
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at FootNote</A> { @I {arrow syntax} is available in certain Haskell implementations, but not in @Omega}}) notation
+used in current Haskell implementations.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A> We intend to tackle these theoretical and practical questions as a follow-on.
 @End @Section
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000440.html">[Al4nin-commits] r677 - trunk/purgatory/db
</A></li>
	<LI>Next message: <A HREF="000442.html">[Al4nin-commits] r679 - trunk/purgatory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#441">[ date ]</a>
              <a href="thread.html#441">[ thread ]</a>
              <a href="subject.html#441">[ subject ]</a>
              <a href="author.html#441">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/al4nin-commits">More information about the Al4nin-commits
mailing list</a><br>
</body></html>
