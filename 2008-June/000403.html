<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Al4nin-commits] r640 - trunk/purgatory
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/al4nin-commits/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:al4nin-commits%40lists.berlios.de?Subject=Re%3A%20%5BAl4nin-commits%5D%20r640%20-%20trunk/purgatory&In-Reply-To=%3C200806111543.m5BFhg9e024246%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000402.html">
   <LINK REL="Next"  HREF="000404.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Al4nin-commits] r640 - trunk/purgatory</H1>
    <B>heisenbug at mail.berlios.de</B> 
    <A HREF="mailto:al4nin-commits%40lists.berlios.de?Subject=Re%3A%20%5BAl4nin-commits%5D%20r640%20-%20trunk/purgatory&In-Reply-To=%3C200806111543.m5BFhg9e024246%40sheep.berlios.de%3E"
       TITLE="[Al4nin-commits] r640 - trunk/purgatory">heisenbug at mail.berlios.de
       </A><BR>
    <I>Wed Jun 11 17:43:42 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000402.html">[Al4nin-commits] r639 - trunk/purgatory
</A></li>
        <LI>Next message: <A HREF="000404.html">[Al4nin-commits] r641 - trunk/purgatory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#403">[ date ]</a>
              <a href="thread.html#403">[ thread ]</a>
              <a href="subject.html#403">[ subject ]</a>
              <a href="author.html#403">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: heisenbug
Date: 2008-06-11 17:43:41 +0200 (Wed, 11 Jun 2008)
New Revision: 640

Modified:
   trunk/purgatory/Thrist.lout
Log:
introduce typographic distinction for the language Cat

Modified: trunk/purgatory/Thrist.lout
===================================================================
--- trunk/purgatory/Thrist.lout	2008-06-06 11:55:28 UTC (rev 639)
+++ trunk/purgatory/Thrist.lout	2008-06-11 15:43:41 UTC (rev 640)
@@ -14,6 +14,7 @@
 
 def @Prompt left input right output { { Helvetica Base -1p } @Font { prompt&gt; @Haskell { input } @PP { output } } }
 def @Omega { {@I {@Sym Omega}}mega }
+def @Cat { { Helvetica Base -1p } @Font Cat }
 
 @Report
   @CoverSheet { No }
@@ -36,7 +37,7 @@
 obtaining the ability to do analysis on them. On the practical side
 we develop three new two-parameter GADTs for inclusion into {@Haskell {Thrist}}s.
 The first, when accompanied by an appropriate interpreter, directly model the semantics
-of the @I Cat language, while the second caters for a new type of parser combinator libraries.
+of the @Cat language, while the second caters for a new type of parser combinator libraries.
 In our third example we demonstrate the use of {@Haskell {Thrist}}s in state machines.
 The @Haskell {Thrist} approach of exposing the intermediate types where the
 elements are joined together especially shows its potential in the ability to
@@ -288,7 +289,7 @@
 Now that we have defined the Thrist datatype and gave a sufficiently
 generic interface to cover nontrivial cases, time has come to look for
 real-world applications. Specifically we shall describe a combinator
-library for creating ASTs of the Cat language, a statically typed stack-
+library for creating ASTs of the @Cat language, a statically typed stack-
 oriented language (&quot;<A HREF="http://www.cat-language.com/">http://www.cat-language.com/</A>&quot;), and a parser
 combinator library. We shall sketch the use of thrists in transition
 arrows of state machines and finally give some curious examples
@@ -300,7 +301,7 @@
 @Title { Application one: the Cat Thrist }
 @Begin
 @PP
-Like all stack-oriented languages Cat employs a simple idiom of
+Like all stack-oriented languages, @Cat employs a simple idiom of
 computation. A rich set of primitives are available for pushing
 values on a stack, permuting them and popping them off. Logical
 and arithmetic primitives consume portions of the top of the stack
@@ -309,11 +310,11 @@
 The semantics of procedure calls is defined as the insertion of the
 called procedure's contents to the point of the invocation.
 @PP
-Let's begin with the definition of the Cat datastucture, that will
+Let's begin with the definition of the @Haskell {Cat} datastucture, that will
 serve as the first parameter to Thrist. Clearly it should be
 parametrized with two types. Naturally we choose the
 first type parameter to describe the shape of the stack before
-and the second parameter after the Cat primitive has been
+and the second parameter after the @Haskell {Cat} primitive has been
 executed.
 
 @TargetForExtract &quot;check/Cat&quot;
@@ -331,19 +332,19 @@
 @Title { First Explorations }
 @Begin
 @PP
-We shall extend our Cat with new primitives as the need arises, but
+We shall extend our @Haskell {Cat} with new primitives as the need arises, but
 for now we have enough to perform some experiments.
 We have chosen the tuple datatype to represent stack shapes,
 but we are free to pick any other sequence-like datatype that
 is able to record the type of each element.
-The Cat datatype is defined as a GADT, which will guarantee
+The @Haskell {Cat} datatype is defined as a GADT, which will guarantee
 that only sematically sound programs can be expressed as a
-Thrist Cat. We can begin our explorations immediately:
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Haskell</A> {Thrist Cat}. We can begin our explorations immediately:
 @LD {
 { Cons (Push 19) $ Cons (Push 23) $ Cons Add $ Cons Pop Nil } @Prompt
 { Cons (Push 19) (Cons (Push 23) (Add (Cons Pop (Cons Add (Cons Pop Nil)))) :: Thrist Cat a a }
 }
-The data we built up can be a representation of a Cat program that
+The data we built up can be a representation of a @Cat program that
 pushes 19 and then 23 on the stack, adds them, keeping only the
 result 42 on the stack, and then pops this result off. The inferred type
 tells us that there is no netto change in the stack's shape.
@@ -372,10 +373,10 @@
 { [Pop, Pop]l } @Prompt
 { [Pop, Pop]l :: Thrist Cat (a, (b, c)) c }
 }
-The inferred type reflects the function of this Cat fragment,
+The inferred type reflects the function of this @Cat fragment,
 namely starting out with a stack that has at least two elements
 pushed, we end up with those two values removed.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">- at LP</A> There are invalid Cat programs, for example addition of two
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LP</A> There are invalid @Cat programs, for example addition of two
 characters:
 @LD {
 { [Push 'a', Dup, Add]l } @Prompt
@@ -389,7 +390,7 @@
 @Title { Interpreter }
 @Begin
 @PP
-Now it is time to build an interpreter for Thrist Cat, and
+Now it is time to build an interpreter for @Haskell {Thrist Cat}, and
 thus define its big-step semantics:
 @ID @Haskell @Begin
 interpret' :: Thrist Cat a b -&gt; a -&gt; b
@@ -461,10 +462,10 @@
 @PP () :: IO () }
 }
 
-It is a reasonable restriction to Cat programs that they can
+It is a reasonable restriction to @Cat programs that they can
 be started with any stack shape and they finish with the same
 stack unchanged. We can ensure this property by writing
-a top-level interpreter function for Cat programs using
+a top-level interpreter function for @Cat programs using
 @I {rank-2 polymorphism}:
 
 @ID @Haskell operators {Base} @Begin
@@ -480,13 +481,13 @@
 @Begin
 @PP
 
-Above we have defined an arithmetic primitive in Cat, namely @Haskell { Add }. While possible,
+Above we have defined an arithmetic primitive in @Cat, namely @Haskell { Add }. While possible,
 it is not desired to define all (which is potentially a lot) primitives this
 way, with their own typing rules, and own clause in the interpreter. Also,
 this approach does preclude a very useful notion, called @I { partial application }. In this
 example, @Haskell { Add } must always be applied to two elements on the stack.
 @PP What we are looking for is a more-or-less generic approach to define
-logical and arithmetic operators in Cat, say, using the @Haskell { Prim (+) }
+logical and arithmetic operators in @Cat, say, using the @Haskell { Prim (+) }
 to frob arithmetic addition from the underlying @Omega implementation.
 
 @LD @Heading { Encountering First Problems }
@@ -520,7 +521,7 @@
 
 @LD @Heading { More Problems while Interpreting }
 Unfortunately we have not mastered everything yet. We remember that
-the semantics of our Cat combinators is defined by the interpretation
+the semantics of our @Haskell {Cat} combinators is defined by the interpretation
 function. So we are obliged to extend @Haskell { interpret }. We can try thus:
 
 @TODO
@@ -582,13 +583,13 @@
 @Begin
 @PP
 A well-known technique to turn an interpreter into a compiler
-is staging. The compile function takes a Thrist Cat into
+is staging. The compile function takes a @Haskell {Thrist Cat} into
 a function of the metalanguage, that when executed causes the
 same effect as the interpretation of the program itself. Naturally,
 the compiled program is expected to run faster, since the interpretative
 overhead is already removed.
 
-We demonstrate the technique for a selection of the Cat primitives
+We demonstrate the technique for a selection of the @Haskell {Cat} primitives
 only.
 
 @ID @Haskell operators {Base} @Begin
@@ -608,11 +609,11 @@
 @Title { Optimization }
 @Begin
 @PP
-The fact that Cat programs are represented as data in the metalanguage
+The fact that @Cat programs are represented as data in the metalanguage
 that is amenable to analysis by pattern matching, we can write an optimization function
 that performs several code optimizations on a program, such as head and tail merging
-of conditionals, value folding, inlining etc. Because the Cat thrist does not admit wrongly
-typed Cat programs and the optimization function takes Thrist Cat to Thrist Cat,
+of conditionals, value folding, inlining etc. Because the @Haskell {Cat} thrist does not admit wrongly
+typed @Cat programs and the optimization function takes @Haskell {Thrist Cat} to @Haskell {Thrist Cat},
 all optimizations must be type preserving.
 @End @SubSubSection
 
@@ -620,9 +621,9 @@
 @Title { Generalization }
 @Begin
 @PP
-The language Cat is intended as an intermediate language produced by
+The language @Cat is intended as an intermediate language produced by
 front-end compilers and consumed by back-ends that target stack based
-virtual machines like JVM and CIL. It is advisable to generalize Cat in a way
+virtual machines like JVM and CIL. It is advisable to generalize @Haskell {Cat} in a way
 that @Haskell {Pop} gets a count parameter that tells how many elements are to be
 popped of the stack. Also instead of @Haskell {Swap} it would be beneficial to have
 a @Haskell {Permute} primitive that subsumes all variants of stack shuffling operations,
@@ -1323,7 +1324,7 @@
 The @I { HaL 2 } workshop gave me the opportunity to discuss the connection
 between categories and thrists, thanks to Heinrich-Gregor Zirnstein,
 for encouragement and to Johan Jeuring for constructive criticism.
-Christopher Diggins corrected some of my views on the Cat language and
+Christopher Diggins corrected some of my views on the @Cat language and
 provided valuable input for the presentation.
 @End @Section
 
@@ -1398,7 +1399,7 @@
 @End @Appendix
 
 @Appendix
-  @Title { A Complete Cat Example: @I fak }
+  @Title { A Complete @Cat Example: @I fak }
 @Begin
 @PP
 @TargetForExtract &quot;check/CatFak&quot;
@@ -1427,7 +1428,7 @@
 {range Bool} = Bool
 @End @Haskell
 
-All types in type universe our (simplified) Cat program can operate on
+All types in type universe our (simplified) @Cat program can operate on
 is witnessed by a value of @Haskell {Tractable}, and @Haskell {sameRep}
 states their equality.
 
@@ -1447,7 +1448,7 @@
 sameRep _ _ = Nothing
 @End @Haskell
 
-Now we can introduce the Cat datatype which fixes the
+Now we can introduce the @Haskell {Cat} datatype which fixes the
 language primitives and typing rules.
 
 @LD @Haskell @Begin


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000402.html">[Al4nin-commits] r639 - trunk/purgatory
</A></li>
	<LI>Next message: <A HREF="000404.html">[Al4nin-commits] r641 - trunk/purgatory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#403">[ date ]</a>
              <a href="thread.html#403">[ thread ]</a>
              <a href="subject.html#403">[ subject ]</a>
              <a href="author.html#403">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/al4nin-commits">More information about the Al4nin-commits
mailing list</a><br>
</body></html>
