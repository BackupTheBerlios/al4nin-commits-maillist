<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Al4nin-commits] r383 - trunk/purgatory
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/al4nin-commits/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:al4nin-commits%40lists.berlios.de?Subject=Re%3A%20%5BAl4nin-commits%5D%20r383%20-%20trunk/purgatory&In-Reply-To=%3C200706201739.l5KHdP71022084%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000144.html">
   <LINK REL="Next"  HREF="000146.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Al4nin-commits] r383 - trunk/purgatory</H1>
    <B>heisenbug at BerliOS</B> 
    <A HREF="mailto:al4nin-commits%40lists.berlios.de?Subject=Re%3A%20%5BAl4nin-commits%5D%20r383%20-%20trunk/purgatory&In-Reply-To=%3C200706201739.l5KHdP71022084%40sheep.berlios.de%3E"
       TITLE="[Al4nin-commits] r383 - trunk/purgatory">heisenbug at mail.berlios.de
       </A><BR>
    <I>Wed Jun 20 19:39:25 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000144.html">[Al4nin-commits] r382 - trunk/purgatory
</A></li>
        <LI>Next message: <A HREF="000146.html">[Al4nin-commits] r384 - trunk/purgatory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#145">[ date ]</a>
              <a href="thread.html#145">[ thread ]</a>
              <a href="subject.html#145">[ subject ]</a>
              <a href="author.html#145">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: heisenbug
Date: 2007-06-20 19:39:24 +0200 (Wed, 20 Jun 2007)
New Revision: 383

Added:
   trunk/purgatory/Thrist.lout
Log:
first raw draft of paper

Added: trunk/purgatory/Thrist.lout
===================================================================
--- trunk/purgatory/Thrist.lout	2007-06-14 21:52:02 UTC (rev 382)
+++ trunk/purgatory/Thrist.lout	2007-06-20 17:39:24 UTC (rev 383)
@@ -0,0 +1,786 @@
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SysInclude</A> { report }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SysInclude</A> { fig }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SysInclude</A> { diag }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SysInclude</A> { graph }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SysInclude</A> { eq }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SysInclude</A> { haskell }
+
+def @Prompt left input right output { prompt&gt; @Haskell { input } @PP @I { output } }
+def @Omega { {@Sym Omega}mega }
+
+#@Database @Reference { refs }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Report</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ColumnNumber</A> { 2 } 
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at InitialFont</A> { Helvetica Base 10p } 
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at DateLine</A> { Yes }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> {
+Thrist: Dominoes of Data
+}
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Author</A> { Gabor Greif }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at AbstractDisplay</A> { Yes }
+# @AbstractFormat { @Centre @Title @DP @Body }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Abstract</A> {
+
+We develop a novel list-like datastructure (which we name Thrist),
+that is able to capture the typing rule of function composition.
+Indeed we show that when Thrist is parameterized with the function
+type constructor (-&gt;) we can provide an interpretation function
+which completely emulates the classical function composition (.). Additionally
+we can perform pattern matching on our Thrist elements, thus
+obtaining the ability to do analysis on them. On the practical side
+we develop two new two-parameter GADTs. The first, when accompanied
+by an appropriate interpreter, directly model the semantics of the Cat language,
+while the second caters for a new type of parser combinator libraries.
+The Thrist approach of exposing the intermediate types where the
+elements are joined together especially shows its potential in the ability to
+stage the interpreter in a type-safe way and only allows for type correct
+transformations.
+
+}
+//
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Section</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Structure of the Paper }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+
+In the first section we motivate our later introduction of Thrist with well known
+examples. In the third section we develop three practial applications of Thrists.
+We also present some less useful but entertaining uses. Section four shows
+up possible future directions and summarizes open problems. Section five concludes.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @Section
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Section</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Introduction }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+We are well acquainted with data structures that are parameterized over
+data types, they are the bread-and-butter tool of functional programmers.
+For example the List datatype could be introduced in Haskell with the following
+definition:
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+data List :: * ~&gt; * where
+  Nil :: List a
+  Cons :: a -&gt; List a -&gt; List a
+}
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+We deliberately avoid the traditional syntax of defining the List datatype,
+and use a GADT-style definition, because we want to build on this fundament later.
+It is enough to say that List does not impose any constraints on the contained datatype
+whatsoever:
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{Cons 42 (Cons 33 (Cons 5 Nil))} @Prompt
+  { Cons 42 (Cons 33 (Cons 5 Nil)) :: List In }
+}
+
+## prompt&gt; Cons 42 (Cons 33 (Cons 5 Nil))
+##  Cons 42 (Cons 33 (Cons 5 Nil)) :: List In
+
+Departing from single-parameter datatypes we focus on two-parameter
+datatypes from now on. The most prominent member of this class of types
+is the arrow type:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{ :k (-&gt;) } @Prompt
+  { (-&gt;) :: *0 ~&gt; *0 ~&gt; *0 }
+}
+
+Fully saturated, a -&gt; b signifies the type of all functions that take elements of a to
+elements of b. Again, a and b can be any type, concrete ones will do just like
+universally qualified ones:
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{id} @Prompt
+  {&lt;fn&gt; : forall a.a -&gt; a}
+}
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{ord} @Prompt
+  {&lt;primfun to1&gt; : Char -&gt; Int}
+}
+Now, functions are a bit more interesting than Lists above, they can be composed!
+Interestingly, composition (written as (.)) is again a function:
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{{(.)} @Prompt
+  {&lt;fn&gt; : forall a b c.(a -&gt; b) -&gt; (c -&gt; a) -&gt; c -&gt; b}
+}
+This function signature has several interpretations, but the most common one tells us that
+the composition function @Haskell {(.)} takes a function with type @Haskell {a -&gt; b} as its first argument, then
+a function with type c -&gt; a as its second argument, and returns a function of type @Haskell {c -&gt; b}.
+Again, a, b and c can be arbitrarily specialized or be left universal.
+We can play with our new toy in the following way:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{ let locase = chr . (\x -&gt; x + 32) . ord } @Prompt
+{ locase }
+
+{  locase 'G' }  @Prompt
+{  'g' : Char }
+}
+
+The type of the composition function constrains the types of its arguments in
+a nontrivial way: the range of the second funtion must match with the domain
+of the first. (universal types will always match, monotypes must be equal).
+Violating this rule gives a type error:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> @Verbatim {
+prompt&gt; ord . ord
+
+In the expression: ord
+the result type: Char -&gt; Int
+was not what was expected: a -&gt; Char
+}
+
+This crucial property of the composition function will guide our explorations in this
+paper.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at BeginSubSections</A>
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Generalizing Function Composition }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+ While function composition seems to be a cute artifact of mathematics, (where
+nevertheless all computable functions can be derived from), this is no reason
+for us to stop at this point! First, we observe that function composition is a one-way
+street: once two functions are composed, they amalgamate beyond recognition.
+There is no way (inside our system) to take them apart again. This is very much
+resembling the addition, where @Haskell { (23 + 19) } gives @Haskell {42} and this result has completely
+lost all memories of the fact how it was obtained. But can we create a datastructure
+that has all properties of function composition, without being amnesiac?
+
+Indeed we can, and the rest of this chapter shall explain how.
+
+Our crucial observation from the introduction was that the types at the ends of the function
+arrows must thread up (we turn around the arrow for this demonstration), intuitively:
+
+b &lt;- a (.) a &lt;- c  ===  b &lt;- c
+        ^^^^^
+
+We also observe that the intermediate types do not show up in the end result's type.
+
+Let's simulate these rules as a datatype:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+data Thrist :: * ~&gt; * ~&gt; * where
+  Nil :: Thrist a a
+  Cons :: (b, a) -&gt; Thrist a c -&gt; Thrist b c
+}
+[here we have a proper GADT]
+
+We can now duplicate the &quot;feeling&quot; of function composition:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Haskell</A> { Cons ('g', 103) (Cons (103, 71) (Cons (71, 'G') Nil)) }
+
+Also we have obtained a datatype that is not amnesiac, it can be
+torn apart at any place by pattern matching, though we have to pay
+the price that the intermediate types are a bit hard to deal with (we revisit this issue later).
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+It appears that we have reached our goal, we can form list-like data where the intermediate
+types thread up, we are happy and name our new toy Thrist, a pormanteau of thread and list.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+Our joy quickly fades away when we compare our thrist with our composition function.
+How can data of type Thrist a b be interpreted as an arrow type a &lt;- b ?
+If we fail to provide this embedding, we cannot consider Thrists being a generalisation of
+function composition.
+
+Not everything is lost, however. Close scrutiny reveals that our usage of (,), pronounced &quot;pair&quot;
+is the culprit. If we could liberate ourselves from this premature decision, we could gain back
+our hope.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSection
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { The Improved Thrist }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+We try all over again, this time abstracting away the pair into an additional parameter:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+data Thrist :: (* ~&gt; * ~&gt; *) ~&gt; * ~&gt; * ~&gt; * where
+  Nil :: Thrist p a a
+  Cons :: p b a -&gt; Thrist p a c -&gt; Thrist p b c
+}
+All that remains of the pair is the bitter taste and the letter &quot;p&quot; in the definition of Thrist.
+It looks like we are getting closer now:
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{ Cons chr (Cons (\x -&gt; x + 32) (Cons ord Nil)) } @Prompt
+{ ... : Thrist (-&gt;) Char Char }
+}
+We have created an arrow thrist!
+
+Immediately we can think of our previous attempt:
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{ Cons ('g', 103) (Cons (103, 71) (Cons (71, 'G') Nil)) } @Prompt
+{  ... : Thrist (,) Char Char }
+}
+The pair thrist that caused us some headache before!
+
+We shall explore some other interesting but sometimes futile
+thrists later in the discussion. But now let's put the last missing
+piece in place to show that an arrow thrist is strictly more general
+than function composition, the runArrowThrist function:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+runArrowThrist :: Thrist (-&gt;) b c -&gt; c -&gt; b
+(TODO)
+}
+
+This function now confirms the vague intuition that Nil plays the r&#244;le of
+the neutral element of the arrow thrist, just like the identity function
+plays the r&#244;le of the neutal element in the monoid of composed functions.
+
+[Question: is every thrist a monoid? &quot;<A HREF="http://en.wikipedia.org/wiki/Monoid">http://en.wikipedia.org/wiki/Monoid</A>&quot;]
+[close with dominoes: &quot;<A HREF="http://en.wikipedia.org/wiki/Dominoes">http://en.wikipedia.org/wiki/Dominoes</A>&quot;]
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at EndSubSections</A>
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @Section
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Section</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Three practical Thrists }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+
+Now that we have defined the Thrist datatype and gave a sufficiently
+generic interface to cover nontrivial cases, time has come to look for
+real-world applications. Specifically we shall describe a combinator
+library for creating ASTs of the Cat language, a statically typed stack-
+oriented language (<A HREF="http://www.cat-language.com/">http://www.cat-language.com/</A>), and a parser
+combinator library. We shall sketch the use of thrists in transition
+arrows of state machines and finally give some curious examples
+that may have some practical value.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at BeginSubSections</A>
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Application One: the Cat Thrist }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+Like all stack-oriented languages Cat employs a simple idiom of
+computation. A rich set of primitives are available for pushing
+values on a stack, permuting them and popping them off. Logical
+and arithmetic primitives consume portions of the top of the stack
+(TOS) and deposit results in their place. Procedures can be defined
+as a succession of primitive invocations and procedure calls.
+The semantics of procedure calls is defined as the insertion of the
+called procedure's contents to the point of the invocation.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+Let's begin with the definition of the Cat datastucture, that will
+serve as the first parameter to Thrist. Clearly it should be
+parametrized with two types. Naturally we choose the
+first type parameter to describe the shape of the stack before
+and the second parameter after the Cat primitive has been
+executed.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+data Cat :: * ~&gt; * ~&gt; * where
+  Push :: a -&gt; Cat opaque (a, opaque)
+  Pop :: Cat (a, opaque) opaque
+  Dup :: Cat (a, opaque) (a, (a, opaque))
+  Add :: Cat (Int, (Int, opaque)) (Int, opaque)
+}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at BeginSubSubSections</A>
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { First Explorations }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+We shall extend our Cat with new primitives as the need arises, but
+for now we have enough to perform some experiments.
+We have chosen the tuple datatype to represent stack shapes,
+but we are free to pick any other sequence-like datatype that
+is able to record the type of each element.
+The Cat datatype is defined as a GADT, which will guarantee
+that only sematically sound programs can be expressed as a
+Thrist Cat. We can begin our explorations immediately:
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{ Cons (Push 19) $ Cons (Push 23) $ Cons Add $ Cons Pop Nil } @Prompt
+{ Cons (Push 19) (Cons (Push 23) (Add (Cons Pop (Cons Add (Cons Pop Nil)))) :: Thrist Cat a a }
+}
+The data we built up can be a representation of a Cat program that
+pushes 19 and then 23 on the stack, adds them, keeping only the
+result 42 on the stack, and then pops this result off. The inferred type
+tells us that there is no netto change in the stack's shape.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Making Use of @Omega{}'s features }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+We shall from now on make use of a feature of the @Omega language
+to define custom syntax for datatypes. Our aim is to hide the
+Thrist constructors Cons and Nil behind a more intuitive fa&#231;ade.
+We shall write the above expression as
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{ [Push 19, Push 23, Add, Pop]l } @Prompt
+{ [Push 19, Push 23, Add, Pop]l :: Thrist Cat a a }
+}
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Omega</A>'s parser and printer perform the conversion to
+the internal form when the list-like brackets [] followed
+by a l letter are encountered.
+
+We can now continue using this terser syntax:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{ [Pop, Pop]l } @Prompt
+{ [Pop, Pop]l :: Thrist Cat (a, (b, c)) c }
+
+The inferred type reflects the function of this Cat fragment,
+namely starting out with a stack that has at least two elements
+pushed, we end up with those two values removed.
+
+There are invalid Cat programs, for example addition of two
+characters:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{ [Push 'a', Dup, Add]l } @Prompt
+{ TYPE ERROR (TODO) }
+
+The GADT-based type inference fails, because Add
+expects two integers on the stack, but there are two
+Chars available instead.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Interpreter }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+Now it is time to build an interpreter for Thrist Cat, and
+thus define its big-step semantics:
+
+interpret' :: Thrist Cat a b -&gt; a -&gt; b
+interpret' []l st = st
+interpret' [Push x; rest]l st = interpret' rest (x, st)
+interpret' [Pop; rest]l (a, st) = interpret' rest st
+interpret' [Dup; rest]l (a, st) = interpret' rest (a, a, st)
+interpret' [Add; rest]l (a, b, st) = interpret' rest (a + b, st)
+
+It works:
+
+prompt&gt; interpret' [Push 19, Push 23, Add]l ()
+  (42, ()) :: (Int, ())
+
+With this basic functionality in place we get bolder and define
+a primitive with side effect:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+data Cat :: * ~&gt; * ~&gt; * where
+  Print :: Cat (a, opaque) opaque
+  ...
+}
+
+To interpret this primitive we have to restructure
+our interpret' function to wrap the stack into the IO monad:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+interpret' :: Thrist Cat a b -&gt; IO a -&gt; IO b
+interpret' [Print; rest]l st = do
+	(a, st') &lt;- st
+	putStr $ show a
+	interpret' rest st'
+  where monad ioM
+}
+In similar spirit we have to rewrite the other cases too:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+interpret' [Pop; rest]l st = do
+	(a, st') &lt;- st
+	interpret' rest $ return st'
+  where monad ioM
+
+interpret' [Push x; rest]l st = do
+	interpret' rest $ return (x, st)
+  where monad ioM
+
+interpret' [Dup; rest]l st = do
+	(a, st') &lt;- st
+	interpret' rest $ return (a, a, st')
+  where monad ioM
+
+interpret' [Add; rest]l st = do
+	(a, b, st') &lt;- st
+	interpret' rest $ return (a + b, st')
+  where monad ioM
+}
+Trying out this monadic interpreter gives us:
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> {
+{ interpret' [Push 21, Dup, Add, Print]l (returnIO ()) } @Prompt
+{ Executing IO action
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LP</A> 42
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A> () :: IO () }
+}
+
+It is a reasonable restriction to Cat programs that they can
+be started with any stack shape and they finish with the same
+stack unchanged. We can ensure this property by writing
+a top-level interpreter function for Cat programs using
+rank-2 polymorphism:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+interpret :: (forall a . Thrist Cat a a) -&gt; IO ()
+interpret program = interpret' program (returnIO Empty)
+}
+Obviously this @Haskell {interpret} function is only called for side-effects.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Extending the Primitives }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+TODO:
+
+frobbing functions from @Omega for use as primitives
+
+using witnesses to describe arities
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Staging the Interpreter }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+A well-known technique to turn an interpreter into a compiler
+is staging. The compile function takes a Thrist Cat into
+a function of the metalanguage, that when executed causes the
+same effect as the interpretation of the program itself. Naturally,
+the compiled program is expected to run faster, since the interpretative
+overhead is already removed.
+
+We demonstrate the technique for a selection of the Cat primitives
+only.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+compile' :: Thrist Cat a b -&gt; Code (IO a -&gt; IO b)
+compile' [Print; rest]l = [| \st -&gt; do
+	(a, st') &lt;- st
+	putStr $ show a
+	$compiledRest st'
+    where monad ioM |]
+  where compiledRest = compile' rest
+}
+
+[TODO: Push, etc.]
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Optimization }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+The fact that Cat programs are represented as data in the metalanguage
+that is amenable to analysis by pattern matching, we can write an optimization function
+that performs several code optimizations on a program, such as head and tail merging
+of conditionals, value folding, inlining etc. Because the Cat thrist does not admit wrongly
+typed Cat programs and the optimization function takes Thrist Cat to Thrist Cat,
+all optimizations must be type preserving.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Generalization }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+The language Cat is intended as an intermediate language produced by
+front-end compilers and consumed by back-ends that target stack based
+virtual machines like JVM and CIL. It is advisable to generalize Cat in a way
+that Pop gets a count parameter that tells how many elements are to be
+popped of the stack. Also instead of Swap it would be beneficial to have
+a Permute primitive that subsumes all variants of stack shuffling operations,
+allowing us to get rid of Swap and friends. All these parametrized primitives
+would have one problem in common, namely that the stack shape would
+vary depending on the  value of the parameter(s), requiring dependent
+types to define them. Fortunately @Omega provides a device that is approaching
+the power of dependent types, singleton types and type-level functions.
+
+Here is a sketch of PopN:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+  PopN :: Nat' (S n) -&gt; Cat {blow (S n) s} s
+}
+It uses the type-level function blow to add the
+necessary number of universal type variables
+to the initial stack's shape:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+blow :: Nat ~&gt; *0 ~&gt; *0
+{blow Z s} = s
+{blow (S n) s} = (t, {blow n s})
+}
+The interpreter can be written thus:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+interpret [PopN (S n); rest]l st -&gt; do
+	(_, st') &lt;- st
+	case n of
+	0v -&gt; interpret' rest st'
+	_ -&gt; interpret' [PopN n; rest]l st'
+}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at EndSubSections</A>
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSection
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Application two: a GADT-based Parse Thrist }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+Traditional monadic parser combinator libraries (like Parsec) suffer from the
+same problem like the composition operator: they compose easily
+but cannot be dissected and analysed, or translated to other
+representations. We proceed similarly to the Thist (-&gt;) and Thrist Cat to
+create a parsing combinator library that is representation agnostic, i.e.
+can be interpreted or compiled and analysed in any reasonable way.
+
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at BeginSubSubSections</A>
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Envisioning Parsing }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+
+But first let's be clear about what we aim at. We demonstrate the process of
+parsing by the example of a lexer with semantic evaluation. Our tokens
+are the various literal numerals like they occur in the C language:
+
+0xcafeBabe 0XE0UL 123456L
+
+These are the steps we wish to proceed on the second token:
+
+0) token as read from character stream:
+
+0XE0UL
+
+1) We match the &quot;0X&quot; prefix
+
+0XE0UL
+--
+
+2) We expect 0 or more hexadecimal characters (we come to the explanation of 0 later)
+
+0XE0UL
+--++
+
+3) We fold the hex string found to a decimal integer
+
+0XE0UL
+--++
+  vv
+
+4) We look for optional signedness hint
+
+0XE0UL
+--++u
+  vv
+
+5) We look for optional storage size hint
+
+0XE0UL
+--++us
+  vv
+
+6) we encapsulate the distilled information into a token datatype
+
+0XE0UL
+--++us
+  vv
+tttttt
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Realization }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+
+To be able to compose these operations we define the GADT Parse:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+data Parse :: * ~&gt; * ~&gt; * where
+  Epsilon :: Parse [a] ([b], [a])       -- always match, return everything
+  Atom :: Char -&gt; Parse Char Char       -- exact match
+  Sure :: (a -&gt; b) -&gt; Parse a b         -- always match and convert
+  Try :: (a -&gt; Maybe b) -&gt; Parse a b    -- pipeline stops if no match
+  Rep1 :: Parse a b -&gt; Parse [a] ([b], [a])          -- consume as many as matches found, return rest
+  Rep :: Parse [a] (b, [a]) -&gt; Parse [a] ([b], [a])  -- consume as many as matches, return rest
+  Group :: [Parse a b] -&gt; Parse [a] ([b], [a])       -- all must match, return rest
+  CataPlus :: ([a] -&gt; b) -&gt; Parse ([a], c) (b, c)    -- collapse one or more elements
+  Par :: Parse a b -&gt; Parse c d -&gt; Parse (a, c) (b, d)
+  Wrap :: Thrist Parse a b -&gt; Parse a b
+}
+
+The datatype Parse a b represents a parser that consumes data of type a
+and if a match is found produces data of type b.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at DashList</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ListItem</A> {  (Atom 'X') matches only the capital X character }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ListItem</A> {  Epsilon matches a zero-size prefix of a list of as and returns an empty list of bs along with the unconsumed rest of as }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ListItem</A> {  (Sure ord) alway matches, consuming a Char and returning its Int ASCII value }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ListItem</A> {  (Try hexdigit) matches only if a characker is a hexadecimal one and returns its hex value, fails otherwise }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ListItem</A> {  (Rep1 (Atom 'X')) matches as many capital Xs as possible and returns a pair consisting the matched and unconsumed portions }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ListItem</A> {  (Group [Atom 'a', Atom 'b']) matches only a prefix &quot;ab&quot; in the input, returning it in a pair along with the unmatched portion or fails otherwise }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ListItem</A> {  (CataPlus foldDec) consumes a pair of a list of digits and some other data, if the list is empty it fails, otherwise it folds the sequence to a number, then returns the pair of this number and the other data, which remains unchanged }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at EndList</A>
+
+In the above descriptions we only suggest a possible semantics, the data of type Parse does not mandate it in any way. So when we talked about &quot;returns soandso&quot; then this is just an intention.
+
+The end result of parsing a token will amount to
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+data Token =
+  Number Int Bool Bool
+  | ...
+}
+So we expect that our parser that produces Tokens to have a type Thrist Parse [Char] ([Token], [Char]).
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> {  }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+How can we use our combinators to describe the parsing steps 0) to 6) above?
+
+First, we use
+
+Group [Atom '0', Atom 'X']
+
+to match the prefix of the string &quot;0XE0UL&quot; and produce (&quot;0X&quot;, &quot;E0UL&quot;) :: ([Char], [Char])
+
+then we can discard the prefix because we know we have to do base 16 conversion later,
+we can use
+
+Sure snd
+
+to do this obtaining &quot;E0UL&quot; :: [Char]. Then
+
+Rep1 $ Try hexdigit
+
+will split off two more characters, converting them to hex values on the way, we obtain ([0, 14], &quot;UL&quot;) :: ([Int], [Char]). We cannot
+discard either component, so we proceed in parallel with
+
+Par (CataPlus foldHex)
+       (Wrap [Rep1 $ Atom 'U', Par (Sure id) (Rep1 $ Atom 'L')]l)
+
+the first component produces 14, the second will proceed by splutting of any 'U' and then
+splitting off any L producing a triple (&quot;U&quot;, (&quot;L&quot;, &quot;&quot;)).
+
+At this stage we have (14, (&quot;U&quot;, (&quot;L&quot;, &quot;&quot;))) :: (Int, ([Char], ([Char], [Char]))).
+
+Finally we feed this into
+
+Try numberToken
+
+that verifies the correct usage of Us and Ls, and creates a pair
+
+(Number 14 True True, &quot;&quot;) :: (Token, [Char])
+
+of the parsed token and the rest of the input.
+
+Putting this together we can write
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at ID</A> @Haskell {
+signedSized = Wrap [Rep1 $ Atom 'U', Par (Sure id) (Rep1 $ Atom 'L')]l
+
+hexToken = Wrap [Group [Atom '0', Atom 'X']
+  , Sure snd
+  , Rep1 $ Try hexdigit
+  , Par (CataPlus foldHex) signedSized
+  , Try numberToken
+  ]l
+
+tokens = Rep hexToken
+}
+
+Of course there are some pitfalls here but the principle is clear:
+
+- the interesting prefix is split off the rest,
+- if the prefix is semantically important it gets condensed to a more appropriate form or else discarded,
+- parallel processing is used if both components of an input pair are relevant.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Defining the Semantics by Interpretation }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+We provide the parse function for the Rep constructor as an example:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at LD</A> @Haskell {
+parse :: Thrist Parse a b -&gt; a -&gt; Maybe b
+
+parse [Rep p; r]l as = parse r (parseRep [p]l as) where
+      parseRep :: Thrist Parse [a] (b, [a]) -&gt; [a] -&gt; ([b], [a])
+      parseRep _ [] = ([], [])
+      parseRep p as = case parse p as of
+                      Nothing -&gt; ([], as)
+                      Just (b, as') -&gt; (b:bs, rest)
+                          where (bs, rest) = parseRep p as'
+}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Compilation }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+Similarly to the Thrist Cat we can compile our parser combinators to
+a more efficient algoritm by removing the interpretative overhead.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Analysis }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+We can run various analyses on our parsers, to ensure that the grammar is unambiguous, for example.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at SubSubSection</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { Outlook }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+Many interesting other combinators can be defined, my repository contains also
+
+  Seq :: Parse [a] (b, [a]) -&gt; Parse [a] (c, [a]) -&gt; Parse [a] ((b, c), [a]) -- parse front first then second
+  Seq1 :: Parse a b -&gt; Parse a c -&gt; Parse [a] ((b, c), [a]) -- same, but with single-elem first and second
+  ButNot1 :: Parse a b -&gt; Parse a b -&gt; Parse a b     -- match first and expect second to fail
+  UpTo :: Parse [a] (b, [a]) -&gt; Parse [a] (c, [a]) -&gt; Parse [a] ((b, c), [a]) -- scan for c then match b
+
+etc.
+
+I think working together with a parsing expert could result in a minimal set of combinators that
+allow parsing a great variety of grammars and optimization and compilation methods that make
+the parsing process *fast*.
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at EndSubSubSections</A>
+
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @SubSection
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at EndSubSections</A>
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @Section
+
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Appendix</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Title</A> { App 1 }
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at Begin</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at PP</A>
+
<A HREF="https://lists.berlios.de/mailman/listinfo/al4nin-commits">+ at End</A> @Appendix
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000144.html">[Al4nin-commits] r382 - trunk/purgatory
</A></li>
	<LI>Next message: <A HREF="000146.html">[Al4nin-commits] r384 - trunk/purgatory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#145">[ date ]</a>
              <a href="thread.html#145">[ thread ]</a>
              <a href="subject.html#145">[ subject ]</a>
              <a href="author.html#145">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/al4nin-commits">More information about the Al4nin-commits
mailing list</a><br>
</body></html>
